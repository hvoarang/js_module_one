<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>js module one</title>
    <link rel="stylesheet" href="/CSS/style.css" />
  </head>
  <body>
    <section class="container">
      <h3 class="title">Основы синтаксиса</h3>
      <p>
        При написании кода важно не просто знать какой символ или конструкцию
        можно использовать, но и прежде всего понимать терминалогию и
        составляющую исходного кода. <br />
        <b>Инструкция (statement)</b> - это связаный набор слов и символов из
        синтаксиса языка, который объеденяется с целью выражения одной идеи,
        одной инструкции для машины
      </p>
      <p class="bg">a = b * 2;</p>
      <p>инструкции в java script завершается точкой с запятой.</p>
      <ul>
        <li>
          a и b - переменные (как в алгебраическом уравнении) это хранилище
          данных, которые использует программа. Переменная состоит из
          идентификатора (имени) и связаного с ним значения
        </li>
        <li>
          2 - простое число - -это называется значением литерала (iteral value),
          потому что не хранится в переменной
        </li>
        <li>
          = и * - операторы, совершающие действия над значением и переменными.
        </li>
      </ul>
      <p>
        Представим что переменная b хранит число 10, тогда инструкция говорит
        машине:
      </p>
      <ol>
        <li>
          Пойди найди переменную с индификатором b и спроси какое у нее сейчас
          значение
        </li>
        <li>Подставь значение переменной b(10) в утвержденное нам место b</li>
        <li>Выполни операцию умножения 10*2</li>
        <li>
          Запиши результат вычесления выражения правой части в переменную а
        </li>
      </ol>
      <h3 class="title">Выражения</h3>
      <p>
        Инструкции состоят из частей как и в любом языке предложения состоят из
        фраз, и эти фразы называются выражениями <br />
        Выражения (expression) - ссылка на переменную либо значение, либо на
        набор переменных и значений в сочетании с оператороми.
      </p>
      <p class="bg">[ [a]=[ [b]*[2] ] ]</p>
      <p>
        Инструкция из примера выше содержит 5 выражений, выделенных квадратными
        скобками для визуализации (это не синтаксис языка)
      </p>
      <ul>
        <li>[2] - это выражение значения литерала</li>
        <li>
          [b] и [a] - выражение переменной, означает необходимость подставить
          значение переменной, но только в том случае, если переменная состоит
          из первой части выражения присвоения
        </li>
        <li>[b*2] - арифметическое значение умножения</li>
        <li>
          [a = b * 2] - выражение присваивания. В нашем случае указывает на
          необходимость вычесления правой части выражения и присваивание
          результата переменной, а в левой части выражение
        </li>
      </ul>
      <p>
        Так же существует выражение вызова, сравнение и т.д <br />
        Когда мы подходим к автомату с кофе или садимся за руль авто существует
        определенный набор элементов в управлении, которыми можно
        взамодействовать. В програмировании это называется интерфейс <br />
        Интерфейс - это набор свойств и методов сущности, доступных для
        использовании в исходном коде.
      </p>
      <h3 class="title">Свойства</h3>
      <p>
        У нас есть свойство: рост, вес, цвет глаз - то есть характеристики,
        описание. Так же и в данных есть свойства, например у строки есть
        свойство ее длины. Синтаксис обращения к свойству очень прост - через
        точку
      </p>
      <p class="bg">сущность.имя_сущности</p>
      <p>
        Для наглядности обратимся к свойству строки length, содержащее
        количество символов строки
      </p>
      <p class="bg">"Hello world".length</p>
      <h3 class="title">Метод</h3>
      <p>
        Это вызов действия, например присетсь или встать, т.е например какая
        нибудь активная операция. Так же и у данных есть свои зараннее
        определенные методы, например можно добавить или удалить элементы из
        коллекции, перевести строку в другой регистр и т.д. Синтаксис вызова
        метода очень похож на обращение к свойству, но в конце добавляется пара
        круглых скобок
      </p>
      <p class="bg">сущность.имя_метода()</p>
      <h3 class="title">Строгий режим</h3>
      <p>
        Новая возможность спецификации - ECMA script5 - которая позволяет
        перевести скрипт в режим полного соответствия современному стандарту.
        Это предотвращает определенные ошибки, например использоване опасных и
        устаревших конструкций <br />
        Для того чтобы перевести скрипт в строгий режим достаточно указать
        директиву в начале js файла.
      </p>
      <p class="bg">"use strict"</p>
      <h3>Переменные и типы</h3>
      <p>
        Переменные используются для хранения данных и состоят из индификаторов
        (имени) и области памяти где хранятся их значения. Переменную можно
        представить в виде коробки с названием, в которой что то лежит
        (значение)
      </p>
      <p class="bg">ключевое_слово имя_переменной = значение</p>
      <p><b>Имена переменных</b></p>
      <p>
        <b>Индификатор</b> - это имя переменной, функции или класса состоит из
        одного или нескольких символов в следующем формате
      </p>
      <ul>
        <li>
          Первым символом должна быть буква a-z или A-Z, символ подчеркивания _
          или $
        </li>
        <li>Другие символы могут быть буквами a-Z и цифрами 0-9, _, $</li>
        <li>
          Индификаторы чувствительны к регистру - это означает что переменные,
          например user, usEr, USER - разные
        </li>
      </ul>
      <p class="bg">
        Имена переменных должны быть понятными <br />
        # ❌ Плохо <br />chislo<br />
        korzina_tovarov <br />profil_polzovatelya<br />
        tekushiy_mesyaz
        <br />
        # ✅ Хорошо<br />
        number <br />тележка <br />Профиль пользователя <br />текущий месяц
        <br />
        colorBar
      </p>
      <p>
        Использование camelCase для индификаторов - это стандарт, первое слово
        пишется строчными буквами а каждое другое прописной. К примеру user,
        getUserData, isActive
      </p>
      <h3 class="title">Ключевые слова</h3>
      <p>
        Существует список зарезервированых ключевых слов, имеющих особое
        значение и используемых для определенных конструкций. Не используйте
        ключевые слова в качестве индификаторов
      </p>
      <img src="/images/key_words.jpg" alt="" />
      <h3>Объявление переменных</h3>
      <p>
        Объявление переменной начинается с ключевого слова const. Такая
        переменная должна быть сразу инициализирована значением, после чего ее
        нельзя переопределить
      </p>
      <p class="bg">
        Переменные, объявленные как const, обязательно должны быть
        инициализированы <br />
        Значением при объявлении иначе будет ошибка <br />
        const yearOfBirthd = 2024; <br />
        console.log(yearOfBirthd);//2024 <br />
        Если изменение объявлено как const перезаписать его значение нельзя, при
        попытке присвоить новое значени возникнет ошибка <br />
        yearOfBirthd = 2020// error
      </p>
      <p>
        Для того чтобы объявить переменную, которой в дальнейшем можно будет
        присвоить новое значение используют ключевое слово let
      </p>
      <p class="bg">
        Переменным, объявленным через let необязательно сразу присваивать
        значение
        <br />
        Если переменной объявленной как let не было присвоено значение она
        инициализируется специальным значением - underfind (не определено).
        <br />
        console.log(age);//underfind <br />
        Консоль лог - это метод вывода данных в консоль браузера <br />
        Если переменная объявлена как let то ее значение можно перезаписать
        <br />
        let age = 14; <br />
        console.log(age); // 14
      </p>
      <p>
        Объявление переменной без слова const и let приведет к ошибке, если
        скрипт выполняется в строгом режиме. <br />
        Единственное отличии const и let заключается в том что const запрещает
        повторно использовать переменной любое значение. Объявление const делает
        код более читабельным, потому что переменная всегда ссылается на одно и
        то же значение. В случае let такой уверенности нет <br />
        Будет разумно использовать let и const следующим образом:
      </p>
      <ul>
        <li>
          Используйте const по умолчанию. Большинство переменных будет обхявлено
          именно таким образом
        </li>
        <li>
          Используйте let если необходимо переменной присвоить другое значение
          во время выполнения скрипта
        </li>
      </ul>
      <h3>Имена КОНСТАНТ</h3>
      <p>
        Имена констант переменных - имена значений, которые не меняются никогда,
        на протяжении работы всего скрипта, как правило записываются в формате
        USER_SNAKE_CASE
      </p>
      <p class="bg">
        Константа, сохраняющая значение цвета <br />
        const COLOR_TEAL = "#009688"; <br />
        Константа, хранящая значение о результате логина <br />
        const LOGIN_SUCCESS_MESSAGE = "Login access";
      </p>
      <p>
        Абсолютное большинство переменных - константы в другом смысле, они
        просто не изменяют значение после присвоения. Но в разных запусках
        скрипта это значение может быть разным. Имена таких переменных
        записываются в формате camelCase <br />
        Обращение к переменной <br />
        Важно различать неопределенные и не объявленные переменные. <br />
        Не определенные (underfind) - это переменная, которая была объявлена
        ключевым словом let но не инициализирована значением. По умолчанию ей
        присваевается первоначально значение underfind
      </p>
      <p class="bg">
        let userName; <br />
        console.log(userName); // underfind
      </p>
      <h3 class="title">Не объявленная (undeclared или not defind)</h3>
      <p>
        Это переменная которая не была объявлена в доступной области видимости.
        Попытка обратиться к переменной приведет к ошибке
      </p>
      <h3 class="title">Примитивные типы</h3>
      <p>
        В Java script переменные не асоциируются с каким либо типом данных, тип
        имеет значение, т.е переменная может сохранять значения разных типов.
      </p>
      <p class="bg">
        <b>number</b> - целые числа и числа с плавающей запятой или точкой<br />
        const age = 20; <br />
        const count = 20.5;
      </p>
      <p class="bg">
        <b>string</b> - строки, последовательные символы от 0 или больше. Строка
        начинается и закачивается ковычками как одинарными так и двойными.<br />
        const username = "Vasya"; <br />
        const description = "Learn js for newbie";
      </p>
      <p class="bg">
        <b>boolean</b> - логический тип данных. Всегда 2 значения: true или
        false. Например на вопрос включен ли свет в комнате - ответ да это true
        или нет это false.<br />
        true - да, верно, истина <br />
        false - нет, неверно, неправда, 0 <br />
        Обратите внимание на имена переменных, содержащих буль. Они задают
        вопросы и ответ на него да или нет. <br />
        const isLoginIn = true; <br />
        const canMarge = false; <br />
        const hasChildren = true; <br />
        const isModalOpen = false; <br />
      </p>
      <p class="bg">
        <b>undefind</b> - это специальное значение. По умолчанию, когда
        переменная объявлена, но не инициализируется, ее значение не определено,
        ей присваивается значение undefind<br />
        let username; <br />
        console.log(username);//undefind
      </p>
      <p class="bg">
        <b>null</b> - это особое значение, которое по существу означает ничто.
        Употребляется в тех ситуациях, когда нужно очевидно показать пустоту.
        Например если пользователь ничего не выбрал то можно сказать что
        значение null.<br />
        let selectProduct = null; <br />
        console.log(selectProduct);//null
      </p>
      <h3 class="title">Оператор typeof</h3>
      <p>
        Используется для получения типа переменной. Возвращает на место своего
        вызова тип переменной, указаного после него - строку, в которой указан
        тип.
      </p>
      <p class="bg">
        let username; <br />
        console.log(typeof username); //"undefind" <br /><br />
        let inputValue = null; <br />
        console.log(typeof inputValue); //"object" <br /><br />
        const quantity = 5; <br />
        console.log(typeof quantity); //"number" <br /><br />
        const message = "Hello World"; <br />
        console.log(typeof message); //"string" <br /><br />
        const isSiderbarOpen = true; <br />
        console.log(typeof isSiderbarOpen); //"boolean" <br /><br />
      </p>
      <h3 class="title">Взаимодействие с пользователем</h3>
      <p>
        Разбираем базовые операции ввода-вывода, достаточные для получения и
        отображение данных от пользователя, прежде чем научимся работать с html
        документом (DOM)
      </p>
      <h3 class="title">Ввод данных</h3>
      <p>
        Для вывода данных существует 2 способа: console.log() и alert(). В
        круглых скобках указываем имя переменной, значение которой нужно ввести
      </p>
      <p class="bg">
        const message = "Hello World"; <br />
        console.log(message);//Hello World <br />
      </p>
      <p>
        Сначала можно указать любую описываемую строку, после чего поставить
        заптую и указать переменную
      </p>
      <p class="bg">
        const username = "Vasya"; <br />
        console.log("username is", username); //username is Vasya
      </p>
      <h3 class="title">Метод alert()</h3>
      <p>
        Выводит модальное окно, текст которого соответствует значению переменной
        или литерала передаваемой в скобках
      </p>
      <p class="bg">
        const message = "Hello World"; <br />
        alert(message);
      </p>
      <p class="information">
        console и alert часть интерфейса window глобального объекта, доступного
        при выполнении скрипта на веб странице. window.alert() лишнее, пишем
        просто alert() или console.log()
      </p>
      <h3 class="title">Получение данных</h3>
      <p>
        Это так же методы интерфейса window. Результатом своего выполнения они
        возвращают то, что было введено пользователем, по этому результат их
        работы можно записать в переменную для дальнейшего использования. <br />
        confirm() - выводит модальное окно с сообщением и 2 кнопки Ok или
        Cancel. Нажимая на Ok результат будет true и нажимая на Cancel результат
        будет false.
      </p>
      <p class="bg">
        //Просим клиента подтвердить бронирование и схраняем результат работы
        confirm() в переменную.
        <br />
        const isComing = confirm("Please confirm select your choise"); <br />
        console.log(isComing);
      </p>
      <h3 class="title">Prompt()</h3>
      <p>
        Выводит модальное окно с полем ввода и кнопкой Ок и Cancel. Нажимая на
        Ок результатом будет то, что пользователь ввел, нажимая на Cancel
        результатом будет null
      </p>
      <p class="bg">
        // Задаем вопрос, который бы хотел оставить user и сохраняем результат
        prompt() в переменную
        <br />
        const username = prompt('Write your name'); <br />
        console.log(username);
      </p>
      <p>
        Важная особенность prompt() состоит в том, что в не зависимости от того
        что ввел пользователь всегда вернется строка. Т.е если пользователь ввел
        5 то вернется не число 5, а строка "5"
      </p>
      <p class="bg">
        const value = prompt("Please enter a number"); <br />
        console.log(typeof value);//string <br />
        console.log(value);// "5"
      </p>
      <h3 class="title">Основные операторы</h3>
      <h4>Математические операторы</h4>
      <p>
        Назначение, функционал и приоритет(порядок) операций ничем не отличается
        от школьного алгебраического курса. Операторы возвращают значение
        посредством результатом выражения
      </p>
      <p class="bg">
        const x = 10; <br />
        const y = 5; <br /><br />
        //Прибавление
        <br />
        console.log(x + y);//15 <br />
        //Вычитание
        <br />
        console.log(x - y);//5 <br />
        //Умножение
        <br />
        console.log(x * y);//50 <br />
        //Деление
        <br />
        console.log(x / y);//2 <br />
        //Остаток от деления
        <br />
        console.log(x% y);//0 <br />
        //Добавление с заменой (так же для всех остальных операторов)
        <br />
        let value = 5; <br />
        //Аналогично записи value = value + 10;
        <br />
        value += 10; <br />
        console.log(value); //15
      </p>
      <h4>Операторы сравнения</h4>
      <p>
        Испульзуются для сравнения двух значений. Результатом своего исполнения
        возвращает буль (true or false)
      </p>
      <p class="bg">
        a > b и a < b - больще/меньше; <br />
        a >= b и a <= b - больше/меньше или равно <br />
        a == b - равенство <br />
        a != b - неравенство <br />
        a === b - строгое равенство <br />
        a !== b - строгое неравенство <br />
      </p>
      <p class="bg">
        const x = 5; <br />
        const y = 10; <br />
        const z = 5; <br />

        console.log('x > y', x > y); //false <br />
        console.log('x < y', x < y); //true <br />
        console.log('x < z', x < z); //false <br />
        console.log('x <= z', x <= z); //true <br />
        console.log('x === y', x === y); //false <br />
        console.log('x === z', x === z); //true <br />
        console.log('x !== y', x !== y); //true <br />
        console.log('x !== z', x !== z); //false <br />
      </p>
      <h4>Операторы равенства</h4>
      <p>
        Нестрогие операторы равенства == и != выполняют преобразование типов
        сравниваемых значений в число, что может привести к ошибкам
      </p>
      <p class="bg">
        // ❌ Плохо, выполняется приведение типов <br />
        console.log(5 == "5") ; //true <br />
        console.log(5 != "5") ; //false <br />
        console.log(1 == true) ; //true <br />
        console.log(1 != true) ; //false <br />
      </p>
      <h4>
        Таблица сравнений с использованием операторов нестрогого равенства
      </h4>
      <img src="/images/ravenstvo.jpg" alt="" />
      <p>
        Поэтому для проверки равенства или неравенства двух значений
        используются операторы только === (строгое равенство) или !== (строгое
        неравенство), не выполняющие приведение типов операндов
      </p>
      <p class="bg">
        // ✅ Хорошо, приведение типов не выполняется <br />
        console . log ( 5 === "5" ); // false <br />
        console . log ( 5 === 5 ); // true <br />
        console . log ( 5 !== "5" ); // true <br />
        console . log ( 5 !== 5 ); // false <br />
        console . log ( 1 === true ); // false <br />
        console . log ( 1 !== true ); // true <br />
      </p>
      <img src="/images/strict.jpg" alt="" />
      <h3 class="title">Числа</h3>
      <p>
        Все числа в js как целые так и дробные имеют тип number, их можно
        записывать не только в десятиричной системе исчесления.
      </p>
      <p><b>Приведение в число</b></p>
      <p>
        Большинство арифметических операций и математических функций превращают
        в число автоматически. Чтобы сделать это явно используйте функцию
        number(value), передавая внутри скобок то что нужно привести к числу.
        Если значение привести к числу не возможно, результатом будет
        специальное цифровое значение NaN(not a number). Аналогичным способом
        происходит превращение и в других математических операторах и функциях
      </p>
      <p class="bg">
        const valueA = "5"; <br />
        console.log(Number(valueA));//5 <br />
        console.log(typeof Number(valueA));//number <br />
        <br />
        const valueB = "random"; <br />
        console.log(Number(valueB)); // NaN<br />
        console.log(typeof Number(valueB)); //number <br />
      </p>
      <p>
        Методы number.parseInt() и number.parseFloat() преобразуют строку символ
        по символу пока это возможно. При возниконовении ошибки возвращает
        итоговое число. Метод number.preseInt() парсит из строки целое число
      </p>
      <p class="bg">
        console.log(Number.parseInt("5"));//5 <br />
        console.log(Number.parseInt("5.asd"));//5 <br />
        console.log(Number.parseInt("5asd")); //5<br />
        console.log(Number.parseInt("asd")); //NaN <br />
        <br />
        console.log(Number.parseFloat("5"));//5 <br />
        console.log(Number.parseFloat("5.2asd"));//5.2 <br />
        console.log(Number.parseFloat("5asd")); //5<br />
        console.log(Number.parseFloat("asd")); //NaN <br />
      </p>
      <p><b>Проверка на число</b></p>
      <p>
        Для проверки на число можно использовать метод Number.isNaN() проверяет
        указано ли значение NaN.Метод отвечает на вопрос - это NaN? И возвращает
        true(NaN) or false(!NaN). Для всех значений value кроме NaN при передаче
        в Number.isNaN() возврат false. Этот метод не пытается превратить value
        в число, а просто выполняет проверку на NaN
      </p>
      <p class="bg">
        const validNumber = Number("500"); //500 <br />
        console.log(Number.isNaN(validNumber)); //false <br /><br />
        const invalidNumber = Number("asd"); //NaN <br />
        console.log(Number.isNaN(invalidNumber)); //true <br /><br />
      </p>
      <p><b>Добавление чисел с подвижной точкой(запятой)</b></p>
      <p>
        Добавляя не целые числа в js и других языках програмирования есть
        особенность. Если кратко то 0.1 + 0.2 не равен 0.3. В результате
        сложения будет больше чем 0.3, это потому что машина считает в двоичной
        системе. <br />
        Число 0.1 в двоичной системе счисления это бесконечная дробь, посколько
        в двоичной системе еденица не делится на десять. Двоичное значение
        бесконечныз дробей сохраняется только до определенного знака, потому
        возникает неточность. При добавлении и 0.1 и 0.2 неточность получается
        незначительной, но все же ошибка в вычеслениях.
      </p>
      <p class="bg">
        console.log(0.1 + 0.2 === 0.3); //false <br />
        console.log(0.1 + 0.2); // 0.30000000000000004 <br />
      </p>
      <p>
        <b>Еще один способ</b> добавить в результат и сократить до определенного
        знака после запятой с помощью метода toFixed()
      </p>
      <p class="bg">
        console.log(0.17 + 0.24); //0.41000000000000003 <br />
        console.log((0.17 + 0.24).toFixed(3)); //0.410 <br />
      </p>
      <p><b>Класс Meth</b></p>
      <p>
        Один из встроенных классов предоставляющий набор методов для работы с
        числами. Знания всех методов наизусть не обязательно, только наиболее
        полезных
      </p>
      <p class="bg">
        // Math.floor(num) взвращает наименьшее целое число, меньше, или равное
        указаному числу <br />
        console.log(Math.floor(1.7)); //1 <br /><br />
        // Math.ceil(num) возвращает наибольшее целое число, больше или равное
        указаному числу
        <br />
        console.log(Math.ceil(1.7)); //2 <br /><br />
        // Math.round(num) возвращает значение числа округленного до ближайшего
        целого
        <br />
        console.log(Math.round(1.7)); //2 <br />
        console.log(Math.round(1.4)); //1 <br /><br />
        // Math.max(num1, num2, ...) возвращает наибольшее целое число из набора
        <br />
        console.log(Math.max(1, 2, 10, 40, 20));//40 <br />
        // Math.min(num1, num2, ...) возвращает наименьшее целое число из набора
        <br />
        console.log(Math.min(1, 2, 10, 40, 20));//1 <br />
        //Math.pow(base, exponent) возведение в степень
        <br />
        console.log(Math.pow(2, 4)); //16 <br />
        //Math.random() возвращает псевдо случайное число в диапазоне от 0. 1
        <br />
        console.log(Math.random());//0-1 <br />
        console.log(Math.random()*(10-1) + 1);//1-10 <br />
      </p>
      <h3 class="title">Строки</h3>
      <p>
        <b>Строка</b> это индексированый набор с 0 или более символов, взятых в
        одинарные или двойные ковычки
      </p>
      <p class="bg">const userName = "vasya";</p>
      <p>
        Важно помнить что индексация элемента строки начинается с 0. Например в
        строке "JavaScript" буква J стоит на позиции с индексом 0, а t под
        индексом 9
      </p>
      <img class="img" src="/images/index.jpg" alt="" />
      <p>
        Содержимое строки нельзя изменить, только прочесть. Т.е нельзя взять
        какой-либо символ и заменить его как только строка создана, она такова
        навсегда. Можно только создать полностью новую строку и присвоить
        переменной новую вместо старой.
      </p>
      <p class="information">
        Если применять оператор + к строке и любому другому типу данных
        результатом операции добавления будет строка. Эта операция называется
        конкатинации или добавлением строк
      </p>
      <p>
        Во время конкатинации любой тип данных приведется к строке и сшивается
        со строкой. Но есть особенность - последовательность записи операндов.
        <br />
        Последовательность операций имеет значение. Преобразование типов
        происходит только в момент операции сложения со строкой. К этому моменту
        действуют привычные правила математики
      </p>
      <p class="bg">
        const message = "JS " + "is" + " awesome"; <br />
        console.log(message);//Js is awesome
      </p>
      <p>Посмотрим на разный порядок операндов</p>
      <p class="bg">
        console.log(1 + "2");//12 <br />
        console.log(1 + "2" + 1);//121 <br />
        console.log(1 + 2 + "1");//31 <br />
      </p>
      <p><b>Шаблонные строки</b></p>
      <p class="information">
        Шаблонные строки это альтернатива конкатинации с более удобным
        синтаксисом. Шаблонная строка берется в обратные косые ковычки вместо
        двойных или одинарных и может содержать заполнители места, обозначеные
        знаком $ и {выражение}
      </p>
      <p class="bg">
        // Испульзуя переменные необходимо составить строчку с подставленными
        значениями
        <br />
        const guestName = "Vasya"; <br />
        const roomNumber = 123; <br />
        const message = "Welcome" + guestName + ", your room number is" +
        roomNumber + "!"; <br />
        console.log(message); <br />
      </p>
      <p>
        Составлять строки с подставленными значениями используя конкатинацию
        очень неудобно. На помощь приходят шаблонные строчки и интерполяция
      </p>
      <p class="bg">
        const guestName = "Vasya"; <br />
        const roomNumber = 123; <br />
        const message = `Welcome ${guestName}, your room number is
        ${roomNumber}!` <br />
        console.log(message); <br />
      </p>
      <h3 class="title">Свойства и методы строк</h3>
      <p>
        В каждой строке есть встроенное свойство и методы. Рассмотрим некоторые
        из них. <br />
        Свойство <b>length</b>. Для того чтобы узнать длинну строки, т.е
        количество ее символов у всех строк есть встроенное свойство length,
        значение которого можно получить обратившись к нему через точку почле
        имени переменной или строчку литерала.
      </p>
      <p class="bg">
        const message = "Welcome to js"; <br />
        console.log(message.length);//13 <br />
        console.log("hello world".length);//11
      </p>
      <p>
        <b>toLowerCase, toUpperCase</b><br />
        Вщзращает новую строчку в соответствуюющем регистре, не изменяя
        оригинальную строку
      </p>
      <p class="bg">
        const message = 'hello world, welcome to js'; <br />
        console.log(message.toUpperCase()); <br />
        console.log(message.toLowerCase());
      </p>
      <p>
        Случаются ситуации когда все символы в строке необходимо преобразовать в
        один регистр верхний или нижний. Например для поиска по ключевому слову,
        когда пользователь вводит строку "SAMSung", а сравнить ее нужно со
        строкой "samsung" или "SAMSUNG"
      </p>
      <p class="bg">
        console.log("SAMSung" === "samsung");//false <br />
        console.log("SAMSung" === "SAMSUNG");//false
      </p>
      <p>
        Чтобы не требовать абсолютно точного воода нужно произвести нормализацию
        введенной пользователем строки, т.е проверить все его символы в верхний
        или нижний регистр. Методы строки toLowerCase() и toUpperCase() вернут
        новую строку в соответствующем рпегистре, не изменяя оригинальную
      </p>
      <p class="bg">
        const BRAND_NAME = "SAMSUNG"; <br />
        const userInput = "SAMSung"; <br />
        const normalizeUppercaseInput = userInput.toUpperCase(); <br />
        console.log(userInput);//SAMSung <br />
        console.log(userInput === BRAND_NAME);//false <br />
        console.log(normalizeUppercaseInput);//SAMSUNG <br />
        console.log(normalizeUppercaseInput === BRAND_NAME);//true
      </p>
      <p>
        <b>indexOf()</b> - возвращает позицию (index), на которой находится
        первое совпадение подстроки или -1 если ничего не найдено
      </p>
      <p class="bg">
        const message = "Hello World"; <br />
        console.log(message.indexOf("Hello"));//0 <br />
        console.log(message.indexOf('asd')); //-1
      </p>
      <p>
        <b>includes()</b> - проверяет находится ли подстрока в строке,
        возвращает буль, true если ссодержится и false если нет. Регистр
        символов в строке и подстроке имеет значение, например буква "а" не
        равно букве "A"
      </p>
      <p class="bg">
        const message = 'Hello World'; <br />
        console.log(message.includes("H"));//true <br />
        console.log(message.includes("h"));//fasle
      </p>
      <p class="information">Все методы строк чувствительны к регистру</p>
      <p>
        <b>endsWith()</b> - позволяет определить завершается ли строка символами
        (подстрококой), указаными в скобках, возвращая true или false
      </p>
      <p class="bg">
        const messageOne = 'Hello World.js'; <br />
        const messageTwo = 'Hello World.css'; <br />
        console.log(messageOne.endsWith(".js"));//true <br />
        console.log(messageTwo.endsWith(".js"));//false
      </p>
      <p>
        <b>replace(), replaceAll()</b> - взвращает новую строку, в которой
        первое(replace()) или совпадение (replaceAll()) подстрока заменены на
        указаное значение
      </p>
      <p class="bg">
        const fileName = 'script.js'; <br />
        const miniJsFileName = fileName.replace('.js', '.min.js'); <br />
        console.log(miniJsFileName); //script.min.js <br />

        const cssFileNames = 'file.css, style.css, min.css';<br />
        const miniCssFileNames = cssFileNames.replaceAll('.css', '.min.css');<br />
        console.log(miniCssFileNames);//file.min.css, style.min.css,
        min.min.css<br />
      </p>
      <p class="information">
        slice() - метод строк slice() (start index, end index) используется для
        создания копии части или всей строки. Он производит копию элемента
        строки от start index и до, но не включая end index и возвращает новую
        строку, не изменяя оригинал.
      </p>
      <p class="bg">
        const productName = "Sushi Box"; <br />
        console.log(productName.slice(0, 5));//Sushi <br />
        console.log(productName.slice(0, productName.length));//Sushi Box
      </p>
      <h3 class="title">Логические операторы</h3>
      <p>
        Логические операторы используются для проверки условий во многих
        выражениях, например в операциях сравнения
      </p>
      <p>
        <b>Приведение типов</b> <br />
        В логических операциях осуществляется приведение типов операнда true или
        false. Привод происходит если в коде обнаружен логический оператор.
        Существует три логических оператора, которые используются для проверки
        выполнения множественных выражений
      </p>
      <img class="img" src="/images/bulean operator.jpg" alt="" />
      <p>
        <b>Логическое И(&&) </b> <br />
        Оператор && приводит все операнды к булю и возвращает значение одного из
        них. Левый операнд если его можно привести в false и правый в других
        случаях <br />
        В следующем примере оба условия вернут true, поэтому результатом всего
        выражения будет true и вернется значение правого операнда
      </p>
      <p class="bg">
        const age = 50; <br />
        console.log(age&gt;10 &amp;&amp; age&lt;60); //true &amp;&amp; true -
        true <br />
      </p>
      <p>
        Если один из операндов будет приведен к false результатом будет его
        значение
      </p>
      <p class="bg">
        const age = 50; <br />
        console.log(age&gt;55 &amp;&amp; age&lt;60); //false &amp;&amp; true -
        false <br />
      </p>
      <p>
        Т.е логические && останавливаются на ложном и возвращают то, на чем
        остановились или последний операнд
      </p>
      <p class="bg">
        console.log(1 && 5);//true && true -- 5 <br />
        console.log(5 && 1);//true && true -- 1<br />
        console.log(0 && 2);//false && true -- 0<br />
        console.log(2 && 0);//true && false -- 0<br />
        console.log("" && "sad");//false && true -- ""<br />
        console.log('sad' && '');//true && false -- ""<br />
        console.log('sad' && 'asdaa');//true && true -- "asdaa"<br />
      </p>
      <p class="information">
        Выполняя логический && первый операнд может не вычесляться в случае если
        левый был приведен к false
      </p>
      <p>
        <b>Логическое "ИЛИ" (||)</b> - оператор || приводит все операнды к булю
        и возвращает значение одного из них. Левый операнд - если его можно
        привести к true и правый в других случаях
      </p>
      <p class="bg">выражение || выражение</p>
      <p>
        В след примере условие слева вернет true, поэтому результатом всего
        выражения будет true. Вернется значение первого оперенда, еоторое было
        приведено к true
      </p>
      <p class="bg">
        const age = 5; <br />
        console.log(age<10 || age>20);//true || false -- true <br />
        console.log(age<3 || age>4); //false || true -- true <br />
        console.log(age<3 || age>20); //false || false -- false
      </p>
      <p>
        Т.е логическое || останавливается на правде или на чем остановилось или
        последний операнд
      </p>
      <p class="bg">
        console.log(true || false); // true <br />
        console.log(false || true); // true<br />
        console.log(true || true); // true<br />

        console.log(3 || false); // 3<br />
        console.log(false || 3); // 3<br />
        console.log(3 || true); // 3<br />
        console.log(true || 3); // true<br />
      </p>
      <p class="information">
        Выполняя логическое || правый операнд может не расчитываться в случае
        если левый был приведен к true
      </p>
      <p>
        <b>Логическое НЕ (!)</b> - все операторы, которые мы рассматривали до
        этого были бинарными - содержат два операнда левый и правый. Логическое
        ! это унарный оператор, выполняющий операцию над одним операндом с
        правой стороны. <br />
        <b>Выражение</b> <br />
        Оператор ! приводит операнд к булю если необходимо, а затем делает
        инверсию, изменяет его на противоположный. True ---> false, false -->
        true.
      </p>
      <p class="bg">
        console.log(!true);//false <br />
        console.log(!false);//true<br />
        console.log(!3);//false<br />
        console.log(!"asd");//false<br />
        console.log(!0);//true<br />
        console.log(!"");//true<br />
        const isOnline = true;<br />
        const isOffline = !isOnline;<br />
      </p>
      <h3 class="title">Разветвление</h3>
      <p>
        Ветвление используется для выполнения разнообразного кода, в зависимости
        от условия. Принцип работы прост - результат условия приводится к булю
        true or false, после чего поток программы устремляется в ту или иную
        сторону.
      </p>
      <p><b>Инструкция if</b></p>
      <img src="/images/else-if.svg" alt="" class="img" />
      <p class="bg">
        if (условие) { <br />
        тело if <br />
        }
      </p>
      <p>
        Приводимые к булю входимые данные называются условия, условия
        устанавливаются после оператора if в круглых скобках. Если условие
        приводится к true, то выполняется код в фигурных скобках тела if
      </p>
      <p class="bg">
        let cost = 0; <br />
        const subscribtion = 'pro'; <br /><br />

        if (subscribtion === 'pro') { <br />
        cost = 100;<br />
        }<br />
        console.log(cost); //100<br />
      </p>
      <p>Если условие приводится к false код фигурных скобок будет пропущен</p>
      <p class="bg">
        let cost = 0; <br />
        const subscribtion = "free";<br /><br />

        if (subscribtion === 'pro') {<br />
        cost = 100;<br />
        }<br /><br />

        console.log(cost);//0
      </p>
      <p><b>Конструкия if-else</b></p>
      <img src="/images/if-else.svg" alt="" class="img" />
      <p class="bg">
        if (условие) { <br />
        тело if <br />
        } else { <br />
        тело else <br />
        }
      </p>
      <p>
        Расширяет синтаксис if таким образом что если приводится к false
        выполняется код в фигурных скобках после оператора else
      </p>
      <p class="bg">
        let cost; <br />
        const subscribtion = "free";<br /><br />

        if (subscribtion === "pro") {<br />
        cost = 100;<br />
        } else {<br />
        cost = 0;<br />
        }<br />
        console.log(cost);//0
      </p>
      <p>Если условие приводится к true тело блока else игнорируется</p>
      <p class="bg">
        let cost; <br />
        const subscribtion = "pro";<br /><br />

        if (subscribtion === "pro") {<br />
        cost = 100;<br />
        } else {<br />
        cost = 0;<br />
        }<br />
        console.log(cost);//100
      </p>
      <p><b>Инструкция else-if </b></p>
      <img class="img" src="/images/else--if.svg" alt="" />
      <p>
        Конструкция if...else может проверить и отреагировать на выполнение или
        невыполнение только одного условия <br />
        Блок else...if позволяет добавить после else еще один оператор if с
        условием. В конце цепочки может быть классический блок else, который
        выполнится только в случае если ни одно условие не приведется к true.
      </p>
      <p class="bg">
        let cost; <br />
        const subscribtion = "premium";<br />

        if (subscribtion === "free") {<br />
        cost = 0;<br />
        } else if (subscribtion === "pro") {<br />
        cost = 100;<br />
        } else if (subscribtion === 'premium') {<br />
        cost = 500;<br />
        } else {<br />
        console.log("Your price is add");<br />
        }<br />
        console.log(cost);//500<br />
      </p>
      <p>
        При первой true проверке прекратится и выполнится только один
        соответствующий сценарий true. Поэтому такую запись стоит читать как -
        ищу первое совпадение и игнорирую все остальные
      </p>
      <h3 class="title">Тернарный оператор</h3>
      <p>
        Тернарный оператор используется в качестве синтаксически более короткой
        замены инструкции if..else когда одной и той же переменной необходимо
        присвоить разные значения по условию
      </p>
      <p class="bg">
        условие <b>?</b> выражение если условие true <b>:</b> выражение если
        условие false
      </p>
      <p>Работает по следующей схеме</p>
      <ul>
        <li>Вычисляется условие</li>
        <li>
          Если условие истина, т.е приводится к true, вычесляется выражение
          после <b>?</b>
        </li>
        <li>
          Если условие ошибочно, т.е приводится к false, вычисляется выражение
          после <b>:</b>
        </li>
        <li>
          Значение вычесленного выражения возвращается как результат работы
          тернарного оператора
        </li>
      </ul>
      <p class="bg">
        let type; <br />
        const age = 20; <br /><br />

        if (age >= 18) {<br />
        type = "adult";<br />
        } else {<br />
        type = "child";<br />
        }<br /><br />

        console.log(type); // "adult"<br />
      </p>
      <p>Выполним рефакторинг заменив if..else тернарными операторами</p>
      <p class="bg">
        const age = 20; <br />
        const type = age >= 18 ? "adult" : "child"; <br />
        console.log(type);
      </p>
      <p>Операция по поиску большего числа</p>
      <p class="bg">
        const num1 = 5; <br />
        const num2 = 10;<br />
        let biggerNumber;<br /><br />

        if (num1 > num2) {<br />
        biggerNumber = num1;<br />
        } else {<br />
        biggerNumber = num2;<br />
        }<br />
        console.log(biggerNumber); //10<br /><br />

        const num1 = 5;<br />
        const num2 = 10;<br />
        let biggerNumber = num1 < num2 ? num2 : num1;<br />
        console.log(biggerNumber);<br />
      </p>
      <p class="information">
        Тернарный оператор должен использоваться в простых операциях присвоения
        или возврата. Его использование для описание сложных ветвлений плохая
        практика (антипаттерн)
      </p>
      <h3 class="title">Инструкция switch</h3>
      <p>
        В некоторых случаях неудобство чтения сложных ветвлений if..else можно
        избежать используя более плоский синтаксис - инструкцию ветвления switch
        <br />
        Пределы применения switch ограничены задачами с одним общим вопросом
        (сравнить) и рядом вариантом ответов (с чем сравнить)
      </p>
      <img src="/images/switch.svg" alt="" class="img" />
      <p>
        Если синтаксис состоит из блока switch (значения) - что нужно сравнить и
        наборов частных случаев case(значение) - с чем нужно сравнить. Для
        сравнения используется ===. Т.е нельзя сравнить больше или меньше,
        только равенство
      </p>
      <p class="bg">
        switch (значение) { <br />
        case значение:<br />
        инструкция;<br />
        breake;<br /><br />

        case значение:<br />
        инструкция;<br />
        breake;<br /><br />

        default: <br />
        инструкция;<br />
        }
      </p>
      <p>
        Значение в блоке switch (значение) - строка или число, сравнимое
        относительно строгого равенства со всеми значениями блока case
        поочередно сверху вниз <br />
        Оператор breake в конце каждого блока case необходим чтобы прервать
        дальшие проверки и сразу перейти к коду switch в том случае когда
        проверка равенства вернула true
        <br /><br />
        Если никакого совпадения не произошло необходимо выполнить код по
        умолчанию, как и в блоке else в инструкции if..else. Для этого после
        всех блоков case добавляется блок default. Оператор breake после блока
        default не нужен, потому что это последняя операция которая будет
        выполнена в swtch и управление будет передано коду после него
      </p>
      <p class="bg">
        let cost; <br />
        const subscribtion = 'premium';<br /><br />

        switch (subscribtion) {<br />
        case 'free':<br />
        cost = 0;<br />
        break;<br />
        case 'pro':<br />
        cost = 100;<br />
        break;<br />
        case 'premium':<br />
        cost = 500;<br />
        break;<br />
        default:<br />
        console.log("Some message");<br />
        }<br />
        console.log(cost);//500<br />
      </p>
      <p class="information">
        Если оператор breake отсутствует то после выполнения любого условия
        case, все последующие за ним строки кода будут выполнятся один за
        другим, что может привести к нежелательным последствиям в случае
        неправильного применения (утечка памяти)
      </p>
      <h3 class="title">Область видимости</h3>
      <p>
        Область видимости переменных (variable scope) - доступность переменных в
        определонном месте кода. <br /><br />
        Глобальная область видимости используется по умолчанию. Каждый имеет
        доступ к переменным, объявленной в ней. Например переменная value
        объявлена в глобальной области видимости, т.е вне любого блока и
        доступна в любом месте после объявления
      </p>
      <p class="bg">
        const value = 5; <br /><br />

        if (true) {<br />
        console.log("Block scope: ", value);//5<br />
        } <br />
        console.log("Global scope: ", value);//5<br />
      </p>
      <p>
        Любая конструкция использующая фигурные скобки {} (условие, циклы,
        функции и т.п) создает новую локальную область видимости и переменные
        объявленные в этой области вилимости с использованием let или const не
        доступны за пределами этого блока
      </p>
      <p class="bg">
        if (true) { <br />
        const value = 5;<br />
        console.log('Block scope: ', value); //5<br />
        }<br />
        console.log('Global scope: ', value); //error
      </p>
      <p>
        Глубина вложенностей областей видимости не ограничена и все они будут
        работать по одному принципу - область видимости имеет доступ ко всем
        переменным,объявленным выше по иерархии вложенности, но не может
        получить доступ к переменным, объявленным во вложенных областях
        видимости.
      </p>
      <img src="/images/var.jpg" alt="" class="img" />
      <ul>
        <li>
          Глобальная область уже присутствует. Создадим в ней переменную global
        </li>
        <li>
          Затем используя оператор if создадим блочную область видимости блока A
        </li>
        <li>
          Внутри области видимости блока А поставим еще один оператор if,
          который создаст вложенную область видимости блока B
        </li>
        <li>
          На одном уровне блока А создадим область видимости блока С так же
          используя оператор if
        </li>
      </ul>
      <p class="bg">
        const global = 'global'; <br /><br />

        if (true) {<br />
        const blockA = 'block A';<br /><br />

        //Видим глобальную плюс локальную А<br />
        console.log(global); //'global'<br />
        console.log(blockA); //'block A'<br /><br />

        //Переменные blockB и blockC не найдены в доступных областях
        видимости<br />
        //Будет ошибка при обращении к переменной<br />
        console.log(blockB); //error<br />
        console.log(blockC); //error<br /><br />

        if (true) {<br />
        const blockB = 'block B';<br /><br />

        //Видим глобальную + внешнюю А + локальную В<br />
        console.log(global); //global<br />
        console.log(blockA); //block A<br />
        console.log(blockB); //block B<br /><br />

        //Переменная blockC не найдена в доступных областях видимости, будет
        ошибка при обращении к ней<br />
        console.log(blockC); //error<br />
        }<br />
        }<br /><br />

        if (true) {<br />
        const blockC = 'block C';<br /><br />

        //Видим глобальную + локальную С<br />
        console.log(global); //global<br />
        console.log(blockC); //block C<br /><br />

        //Переменная blockA и blockB не найдены в области видимости, будет
        ошибка при обращении к ним<br />
        console.log(blockA); //error<br />
        console.log(blockB); //error<br />
        }<br /><br />

        //Видим только глобальную<br />
        console.log(global); //global<br /><br />

        //Переменные blockA, blockB, blockC не найдены, будет ошибка при
        обращении к ним<br />
        console.log(blockA); //error<br />
        console.log(blockB); //error<br />
        console.log(blockC); //error<br />
      </p>
      <p class="information">
        Будьте внимательны при использовании областей видимости и переменных
        объявленных в них. Именно это заблуждение вместе с невнимательностью
        часто становится головной болью для начинающих
      </p>
      <h3 class="title">Циклы</h3>
      <p>
        Задача програмирования - многократное выполнение однотипного действия. К
        примеру вывести клиетов из списка один за другим или перебрать суммы
        зарплат и для каждой выполнить одинаковый код. Именно для таких целей
        многократно повторяется одна и та же часть кода, используется цикл
      </p>
      <ul>
        <li>
          <b>Цикл</b> - управляющая конструкция в высокоуровневых языках
          программирования, предназначенная для организации многократного
          выполнения инструкций.
        </li>
        <li>
          <b>Тело цикла</b> - последовательность инструкций, предназначенная для
          многократного выполнения
        </li>
        <li><b>Итерация</b> - однократное исполнение тела цикла</li>
        <li>
          <b>Условие выхода</b> - выражение, определяющее будет ли в очередной
          раз выполняться итерация или цикл завершиться
        </li>
        <li>
          <b>Счетчик (count)</b> - переменная, сохраняющая текущий номер
          итерации. Цикл не обязательно содержит счетчик и он не должен быть
          один, условие выхода из цикла может зависеть от нескольких,
          изменяющихся в цикле переменных
        </li>
      </ul>
      <h3 class="title">Цикл while</h3>
      <p>
        Цикл с предпосылкой. Выполняемый цикл, пока условие правдивое. Это
        условие проверяется до выполнения тела цикла, поэтому тело может не
        выполнится ниразу если условие изначально false
      </p>
      <p class="bg">
        while (condition) { <br />
        // код, тело цикла (statement)
        <br />
        }
      </p>
      <p>
        Конструкция while создает цикл, выполняющий блок кода пока условие
        проверки оценивается как true
      </p>
      <ul>
        <li>Condition т.е условие оцениваемое перед каждой итерацией цикла</li>
        <li>
          Если condition оценивается как true, оператор while выполняет
          statement
        </li>
        <li>
          Если condition оценивается как false выполнение цикла прерывается и
          скрипт продолжает следовать инструкции после цикла while
        </li>
      </ul>
      <img src="/images/while.jpg" alt="" class="img" />
      <p class="bg">
        //Создадим счетчик
        <br />
        let counter = 0; <br /><br />

        while (counter < 10) {<br />
        console.log("Counter: ", counter);<br />
        counter += 1;<br />
        }
      </p>
      <p>
        Будем заполнять места в отеле, пока колличество клиентов не будет
        максимально возможным
      </p>
      <p class="bg">
        let clientCounter = 18; <br />
        const maxClients = 25;<br /><br />

        while (maxClients >= clientCounter) {<br />
        console.log('Clients in hotel: ', clientCounter);<br />
        clientCounter += 1;<br />
        }
      </p>
      <h3 class="title">Цикл do...while</h3>
      <p>
        <b>Цикл с пост условием</b> - цикл в котором условие проверяется после
        выполнения тела цикла. Из этого следует что тело выполняется хотябы один
        раз
      </p>
      <p class="bg">
        do { <br />
        // оператор <br />
        } while (условие) ;<br />
      </p>
      <p>
        Конструкция do...while создает цикл, выполняющий блок кода, пока
        condition не вернет false. <br />
        В отличае от цикла while цикл do..while всегда выполняет statement
        минимум один раз прежде чем он оценит condition. <br />
        Внутри цикла нужно внести изменения в некоторую переменную, чтобы
        убедиться что выражение равно false после итерации, иначе будет
        неискончаемый цикл <br />
        <br />
        <b>Блок схема илюстрирует цикл do..while</b>
      </p>
      <img src="/images/do-while.png" alt="" class="img" />
      <p class="bg">
        let password = ''; <br /><br />

        do {<br />
        password = prompt('Enter your password longer than 4 numbers', '');<br />
        } while (password.length < 5);<br /><br />

        console.log('Your password: ', password);<br />
      </p>
      <h3 class="title">Цикл for</h3>
      <p>
        <b>Цикл с счетчиком</b> - цикл, в котором определенная переменная
        изменяет свое значение из заданого начального к конечному значению с
        некоторым шагом и для каждого значения этой переменной тело цикла
        выполняется один раз <br />
        В большинтсве процедурных языков программирования реализуется
        конструкция for в которой указывается счетчик, необходимого количества
        итераций и шагов с которым меняется счетчик
      </p>
      <p class="bg">
        for (инициализация; условие ; поствыражение ) {
        <br />
        // операторы<br />
        }<br />
      </p>
      <ul>
        <li><b>Алгоритм выполнения цикла for</b></li>
        <li>
          Инициализация выполняется один раз до начала цикла. Используется для
          создания переменной счетчика и указания ее начального значения
        </li>
        <li>
          Условие (condition) - выражение, оцениваемое перед каждой итерации
          цикла. Тело цикла выполняется только тогда, когда выражение приводится
          к true. Цикл завершается если значение будет false
        </li>
        <li>
          Тело (statement) - набор инструкций для выполнения на каждом
          повторении. Выполняется если выражение условия приводится к true
        </li>
        <li>
          Поствыражение (postexpression) - выполняется в конце каждого
          повторения цикла до проверки условия. Используется для обновления
          переменной счетчика
        </li>
      </ul>
      <p><b>Переменные - счетчики по традиции называются буквами (a-z)</b></p>
      <p class="bg">
        for (let i = 0; i <= 20; i += 5) { <br />

        console.log(i);<br />
        }
      </p>
      <p>
        В примере объявляется переменная счетчик i и инициализируется значением
        0 и цикл выполняется до тех пор, пока i <=20, т.е условие приводится к
        true. После каждой итерации счетчик увеличивается на 5. <br />
        <b>Подсчитаем сумму чисел до определенного значения </b>
      </p>
      <p class="bg">
        const target = 3; <br />
        let summ = 0;<br /><br />

        for (let i = 0; i <= target; i += 1) {<br />
        summ += i;<br />
        }<br /><br />

        console.log(summ);
      </p>
      <p>
        <b
          >Упомянем об операциях a % b и выведем остаток от деления с помощью
          цикла</b
        >
      </p>
      <p class="bg">
        const max = 10; <br /><br />

        for (let i = 0; i < max; i += 1) {<br />
        console.log(`${max} % ${i} = `, max % i);<br />
        }
      </p>
      <h3 class="title">Оператор break</h3>
      <p>
        Прервать выполнения цикла можно в любой момент, для этого существует
        оператор breake, который полностью прекращает выполнение цикла и
        передает управление на строчку после его тела <br /><br />
        Найдем число 3. Как только выполнится условие if цикл прекратит свое
        исполнение
      </p>
      <p class="bg">
        for (let i = 0; i <= 5; i += 1) { <br />
        console.log(i);<br /><br />

        if (i === 3) {<br />
        console.log('Found number 3');<br />
        break;<br />
        }<br />
        }<br /><br />

        console.log("Lock after for()");
      </p>
      <h3 class="title">Оператор continue</h3>
      <p>
        Прерывает не весь цикл, а только выполнение текущей итерации. Его
        используют если понятно что на текущей итерации цикла больше нечего
        делать и пора переходить к след итерации <br /><br />
        Используем цикл для ввода только нечетных чисел. Для парных i
        срабатывает continue, исполнение тела прекращается и управление
        передается к след итерации
      </p>
      <p class="bg">
        const num = 10; <br /><br />

        for (let i = 0; i < num; i += 1) {<br />
        if (i % 2 === 0) {<br />
        continue;<br />
        }<br /><br />

        console.log("Нечетные i: ", i);<br />
        }
      </p>
    </section>
  </body>
  <script src="/js/module_1.js"></script>
  <script src="/js/test.js"></script>
</html>
